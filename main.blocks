<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="ISf4^$tW2{}k`mtvc,O?" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="({W4W1cNc8l.1v^a`PIL" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace behavior {" line1="" line2="    export interface Behavior {" line3="        // sprite : Sprite;" line4="        update() : boolean;" line5="        // moveTo(sprite: Sprite) : boolean;" line6="    }" line7="" line8="    export enum MovePattern {" line9="        Bounce," line10="        TurnIfOnWall," line11="        BounceAndTurnOnSideWall," line12="        FlyAndTurnOnSideWall," line13="    }" line14="" line15="    class SpriteBehavior implements Behavior {" line16="        _sprite: Sprite;" line17="        _vx: number;" line18="        _vy: number;" line19="" line20="        _move : Behavior;" line21="        _follow : Behavior;" line22="        _attack : Behavior;" line23="" line24="        constructor(sprite: Sprite) {" line25="            this._sprite = sprite;" line26="            this._sprite.setFlag(SpriteFlag.StayInScreen, false);" line27="        }" line28="        get sprite() : Sprite {" line29="            return this._sprite;" line30="        }" line31="        vxvy(vx: number, vy: number) {" line32="            this._sprite.vx = this._vx = Math.abs(vx);" line33="            this._sprite.vy = this._vy = Math.abs(vy);" line34="        }" line35="        get x() : number {" line36="            return this._sprite.x;" line37="        }" line38="        get y() : number {" line39="            return this._sprite.y;" line40="        }" line41="        update() : boolean {" line42="            let updated = true;" line43="            if( updated &amp;&amp; this._move )" line44="                updated = this._move.update();" line45="            if( updated &amp;&amp; this._follow )" line46="                updated = this._follow.update();" line47="            if( this._attack )" line48="                this._attack.update();" line49="            return updated;" line50="        }" line51="        moveRight() {" line52="            this._sprite.vx = this._vx;" line53="        }" line54="        moveLeft() {" line55="            this._sprite.vx = this._vx * -1;" line56="        }" line57="        moveTo(target: Sprite) : boolean {" line58="            if( target.x &lt; this._sprite.x ) {" line59="                this.moveLeft();" line60="                return true;" line61="            } else if( this._sprite.x &lt; target.x ) {" line62="                this.moveRight();" line63="                return true;" line64="            }" line65="            return false;" line66="        }" line67="        fall() {" line68="            let vy = this._sprite.vy;" line69="            this._sprite.vy = Math.min(vy+8, this._vy);" line70="        }" line71="        jumpIfOnGround() : boolean {" line72="            if (this._sprite.isHittingTile(CollisionDirection.Bottom)) {" line73="                this._sprite.vy = this._vy * -1;" line74="                return true;" line75="            }" line76="            return false;" line77="        }" line78="        ternIfOnWall() : boolean {" line79="            if (this._sprite.isHittingTile(CollisionDirection.Left)) {" line80="                this.moveRight();" line81="                return true;" line82="            } else if (this._sprite.isHittingTile(CollisionDirection.Right)) {" line83="                this.moveLeft();" line84="                return true;" line85="            }" line86="            return false;" line87="        }" line88="    }" line89="" line90="    class MoverBehavior implements Behavior {" line91="        _parent: SpriteBehavior;" line92="        constructor(parent: SpriteBehavior, vx: number, vy: number) {" line93="            this._parent = parent;" line94="            this._parent.vxvy(vx, vy);" line95="        }" line96="        update() : boolean {" line97="            return false;" line98="        }" line99="    }" line100="" line101="    class BounceBehavior extends MoverBehavior {" line102="        constructor(parent: SpriteBehavior) {" line103="            super(parent, 0, 120);" line104="        }" line105="        update() : boolean {" line106="            this._parent.fall();" line107="            return this._parent.jumpIfOnGround();" line108="        }" line109="    }" line110="" line111="    class TurnIfOnWallBehavior extends MoverBehavior {" line112="        constructor(parent: SpriteBehavior) {" line113="            super(parent, 50, 200);" line114="        }" line115="        update() : boolean {" line116="            this._parent.fall();" line117="            this._parent.ternIfOnWall();" line118="            return true;    // always true" line119="        }" line120="    }" line121="" line122="    class BounceAndTurnOnSideWallBehavior extends MoverBehavior {" line123="        constructor(parent: SpriteBehavior) {" line124="            super(parent, 50, 200);" line125="        }" line126="        update() : boolean {" line127="            this._parent.fall();" line128="" line129="            if( this._parent.jumpIfOnGround() ) {" line130="                return true;" line131="            }" line132="            " line133="            if( this._parent.ternIfOnWall() ) {" line134="                return true;" line135="            }" line136="" line137="            return false;" line138="        }" line139="    }" line140="" line141="    class FlyAndTurnOnSideWallBehavior extends MoverBehavior {" line142="        constructor(parent: SpriteBehavior) {" line143="            super(parent, 50, 0);" line144="        }" line145="        update() : boolean {" line146="            return this._parent.ternIfOnWall();" line147="        }" line148="    }" line149="" line150="    class FollowerBehavior implements Behavior {" line151="        _follower: SpriteBehavior" line152="        _followTarget: Sprite;" line153="        constructor(follower: SpriteBehavior, followTarget: Sprite) {" line154="            this._follower = follower;" line155="            this._followTarget = followTarget;" line156="        }" line157="        update() : boolean {" line158="            return this._follower.moveTo(this._followTarget);" line159="        }" line160="    }" line161="" line162="    class AttackerBehavior implements Behavior {" line163="        _attacker: SpriteBehavior" line164="        _attackTarget: Sprite;" line165="        _bullet: Sprite" line166="        _time: number;" line167="        constructor(attacker: SpriteBehavior, attackTarget: Sprite, bullet: Sprite) {" line168="            this._attacker = attacker;" line169="            this._attackTarget = attackTarget;" line170="            this._bullet = bullet;" line171="            this._bullet.setFlag(SpriteFlag.Invisible, true);" line172="            this._time = game.runtime();" line173="        }" line174="        update() : boolean {" line175="            let time = game.runtime();" line176="" line177="            let diff = time - this._time;" line178="            if( diff &gt; 1000) {" line179="                this._onFire();" line180="                this._time += diff;" line181="            }" line182="" line183="            return true;" line184="        }" line185="" line186="        protected _onFire() {" line187="" line188="            let x = this._attackTarget.x - this._attacker.x;" line189="            let y = this._attackTarget.y - this._attacker.y;" line190="" line191="            if( Math.abs(x) &lt; 5 &amp;&amp; Math.abs(y) &lt; 5)" line192="                return;" line193="" line194="            let n = Math.abs(x) + Math.abs(y);" line195="            let vx = x / n * 150;" line196="            let vy2 = y / n * 150;" line197="" line198="" line199="            // console.log(&quot;_onFire() x:&quot; + x + &quot; y:&quot; + y);" line200="" line201="            let bullet = sprites.create(this._bullet.image, this._bullet.kind());" line202="            bullet.setFlag(SpriteFlag.DestroyOnWall, true);" line203="            bullet.vx = vx;" line204="            bullet.vy = vy2;" line205="            bullet.x = this._attacker.x;" line206="            bullet.y = this._attacker.y;" line207="        }" line208="    }" line209="" line210="    class Item {" line211="        sprite:Sprite;" line212="        behavior:SpriteBehavior;" line213="    }" line214="" line215="    let _items: Item[] = [];" line216="    game.onUpdate(() =&gt; {" line217="        for(let item of _items) {" line218="            item.behavior.update();" line219="        }" line220="    })" line221="" line222="    //% block=&quot;set $pattern pattern of $sprite=variables_get(aEnemy)&quot;" line223="    export function setPattern(sprite: Sprite, pattern: MovePattern) {" line224="        let _item = _findItemBySprite(sprite);" line225="        if( !_item ) {" line226="            _item = new Item();" line227="            _item.sprite = sprite;" line228="            _item.behavior = new SpriteBehavior(sprite);" line229="            _addItem(_item);" line230="        }" line231="" line232="        _item.behavior._move = _createMoverBehavior(_item.behavior, pattern);" line233="    }" line234="" line235="    //% block=&quot;set $sprite=variables_get(aEnemy) to follow $target=variables_get(mySprite)&quot;" line236="    export function setFollower(sprite: Sprite, target: Sprite) {" line237="        let _item2 = _findItemBySprite(sprite);" line238="        if( !_item2 ) {" line239="            _item2 = new Item();" line240="            _item2.sprite = sprite;" line241="            _item2.behavior = new SpriteBehavior(sprite);" line242="            _addItem(_item2);" line243="        }" line244="" line245="        _item2.behavior._follow = new FollowerBehavior(_item2.behavior, target);" line246="    }" line247="" line248="    //% block=&quot;set $sprite=variables_get(aEnemy) to attack $target=variables_get(mySprite) by $bullet=variables_get(aBullet)&quot;" line249="    export function setAttacker(sprite: Sprite, target: Sprite, bullet: Sprite) {" line250="        let _item3 = _findItemBySprite(sprite);" line251="        if( !_item3 ) {" line252="            _item3 = new Item();" line253="            _item3.sprite = sprite;" line254="            _item3.behavior = new SpriteBehavior(sprite);" line255="            _addItem(_item3);" line256="        }" line257="" line258="        _item3.behavior._attack = new AttackerBehavior(_item3.behavior, target, bullet);" line259="    }" line260="" line261="    function _addItem(item: Item) {" line262="        item.sprite.onDestroyed(() =&gt; {" line263="            let _item22 = _findItemBySprite(item.sprite);" line264="            _items.removeElement(_item22);" line265="        });" line266="        _items.push(item);" line267="        // console.log(&quot;_items.length:&quot; + _items.length);" line268="    }" line269="" line270="    function _findItemBySprite(sprite:Sprite) {" line271="        let found = _items.find((_item: Item, index: number) =&gt; {" line272="            return _item.sprite == sprite;" line273="        });" line274="        if( found == undefined || found == null)" line275="            return null" line276="        return found;" line277="    }" line278="" line279="    function _createMoverBehavior(spriteBehavior: SpriteBehavior, pattern: MovePattern) : Behavior {" line280="        switch(pattern) {" line281="        case MovePattern.Bounce:" line282="            return new BounceBehavior(spriteBehavior);" line283="        case MovePattern.TurnIfOnWall:" line284="            return new TurnIfOnWallBehavior(spriteBehavior);" line285="        case MovePattern.BounceAndTurnOnSideWall:" line286="            return new BounceAndTurnOnSideWallBehavior(spriteBehavior);" line287="        case MovePattern.FlyAndTurnOnSideWall:" line288="            return new FlyAndTurnOnSideWallBehavior(spriteBehavior);" line289="        default:" line290="            return null;" line291="        }" line292="    }" line293="" line294="}" numlines="295"></mutation></block></statement></block></xml>