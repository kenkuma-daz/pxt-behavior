<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="*]D6KQ%S@Zx+X9^(@A}S" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="4NETRd*{)qbL;zmMnqBZ" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace behavior {" line1="" line2="    export interface Behavior {" line3="        update() : boolean;" line4="    }" line5="" line6="    export enum MovePattern {" line7="        Bounce," line8="        TurnIfOnWall," line9="        BounceAndTurnOnSideWall," line10="        FlyAndTurnOnSideWall," line11="        WalkOnFloor" line12="    }" line13="" line14="    class SpriteBehavior implements Behavior {" line15="        _sprite: Sprite;" line16="        _vx: number;" line17="        _vy: number;" line18="" line19="        _move : Behavior;" line20="        _follow : Behavior;" line21="        _animation : Behavior;" line22="        _attack : Behavior;" line23="" line24="        constructor(sprite: Sprite) {" line25="            this._sprite = sprite;" line26="            this._sprite.setFlag(SpriteFlag.StayInScreen, false);" line27="        }" line28="        get sprite() : Sprite {" line29="            return this._sprite;" line30="        }" line31="        vxvy(vx: number, vy: number) {" line32="            this._sprite.vx = this._vx = Math.abs(vx);" line33="            this._sprite.vy = this._vy = Math.abs(vy);" line34="        }" line35="        get x() : number {" line36="            return this._sprite.x;" line37="        }" line38="        get y() : number {" line39="            return this._sprite.y;" line40="        }" line41="        get vx() : number {" line42="            return this._sprite.vx;" line43="        }" line44="        get vy() : number {" line45="            return this._sprite.vy;" line46="        }" line47="        update() : boolean {" line48="            let updated = true;" line49="            if( updated &amp;&amp; this._move )" line50="                updated = this._move.update();" line51="            if( updated &amp;&amp; this._follow )" line52="                updated = this._follow.update();" line53="            if( this._animation )" line54="                this._animation.update();" line55="            if( this._attack )" line56="                this._attack.update();" line57="            return updated;" line58="        }" line59="        moveRight() {" line60="            this._sprite.vx = this._vx;" line61="        }" line62="        moveLeft() {" line63="            this._sprite.vx = this._vx * -1;" line64="        }" line65="        moveTo(target: Sprite) : boolean {" line66="            if( target.x &lt; this._sprite.x ) {" line67="                this.moveLeft();" line68="                return true;" line69="            } else if( this._sprite.x &lt; target.x ) {" line70="                this.moveRight();" line71="                return true;" line72="            }" line73="            return false;" line74="        }" line75="        fall() {" line76="            let vy = this._sprite.vy;" line77="            this._sprite.vy = Math.min(vy+8, this._vy);" line78="        }" line79="        jumpIfOnGround() : boolean {" line80="            if (this._sprite.isHittingTile(CollisionDirection.Bottom)) {" line81="                this._sprite.vy = this._vy * -1;" line82="                return true;" line83="            }" line84="            return false;" line85="        }" line86="        ternIfOnWall() : boolean {" line87="            if (this._sprite.isHittingTile(CollisionDirection.Left)) {" line88="                this.moveRight();" line89="                return true;" line90="            } else if (this._sprite.isHittingTile(CollisionDirection.Right)) {" line91="                this.moveLeft();" line92="                return true;" line93="            }" line94="            return false;" line95="        }" line96="" line97="        _isWallAt(x:number, y:number) : boolean {" line98="            let loc : tiles.Location = tiles.getTileLocation(x &gt;&gt; 4, y &gt;&gt; 4);" line99="            const tm = game.currentScene().tileMap;" line100="            return tm ? tm.isObstacle(loc.col, loc.row) : false;" line101="        }" line102="" line103="        walkOnFloor() : boolean {" line104="            if (!this._isWallAt(this._sprite.x-8 , this._sprite.y+16) ) {" line105="                this.moveRight();" line106="                return false;" line107="            } else if (!this._isWallAt(this._sprite.x+8 , this._sprite.y+16) ) {" line108="                this.moveLeft();" line109="                return false;" line110="            }" line111="            return true;" line112="        }" line113="" line114="    }" line115="" line116="    class MoverBehavior implements Behavior {" line117="        _parent: SpriteBehavior;" line118="        constructor(parent: SpriteBehavior, vx: number, vy: number) {" line119="            this._parent = parent;" line120="            this._parent.vxvy(vx, vy);" line121="        }" line122="        update() : boolean {" line123="            return false;" line124="        }" line125="    }" line126="" line127="    class BounceBehavior extends MoverBehavior {" line128="        constructor(parent: SpriteBehavior, vx: number, vy: number) {" line129="            super(parent, vx, vy);" line130="        }" line131="        update() : boolean {" line132="            this._parent.fall();" line133="            return this._parent.jumpIfOnGround();" line134="        }" line135="    }" line136="" line137="    class TurnIfOnWallBehavior extends MoverBehavior {" line138="        constructor(parent: SpriteBehavior, vx: number, vy: number) {" line139="            super(parent, vx, vy);" line140="        }" line141="        update() : boolean {" line142="            this._parent.fall();" line143="            this._parent.ternIfOnWall();" line144="            return true;    // always true" line145="        }" line146="    }" line147="" line148="    class BounceAndTurnOnSideWallBehavior extends MoverBehavior {" line149="        constructor(parent: SpriteBehavior, vx: number, vy: number) {" line150="            super(parent, vx, vy);" line151="        }" line152="        update() : boolean {" line153="            this._parent.fall();" line154="" line155="            if( this._parent.jumpIfOnGround() ) {" line156="                return true;" line157="            }" line158="            " line159="            if( this._parent.ternIfOnWall() ) {" line160="                return true;" line161="            }" line162="" line163="            return false;" line164="        }" line165="    }" line166="" line167="    class FlyAndTurnOnSideWallBehavior extends MoverBehavior {" line168="        constructor(parent: SpriteBehavior, vx: number, vy: number) {" line169="            super(parent, vx, 0);" line170="        }" line171="        update() : boolean {" line172="            return this._parent.ternIfOnWall();" line173="        }" line174="    }" line175="" line176="    class WalkOnFloorBehavior extends MoverBehavior {" line177="        constructor(parent: SpriteBehavior, vx: number, vy: number) {" line178="            super(parent, vx, vy);" line179="        }" line180="        update() : boolean {" line181="            this._parent.fall();" line182="            return this._parent.walkOnFloor();" line183="            // return false;" line184="        }" line185="    }" line186="" line187="    class FollowerBehavior implements Behavior {" line188="        _follower: SpriteBehavior" line189="        _followTarget: Sprite;" line190="        constructor(follower: SpriteBehavior, followTarget: Sprite) {" line191="            this._follower = follower;" line192="            this._followTarget = followTarget;" line193="        }" line194="        update() : boolean {" line195="            return this._follower.moveTo(this._followTarget);" line196="        }" line197="    }" line198="" line199="    class AnimationBehavior implements Behavior {" line200="        _parent: SpriteBehavior;" line201="        _leftFrames: Image[];" line202="        _rightFrames: Image[];" line203="        _interval: number;" line204="        _direction: number;" line205="        _x: number;" line206="        _y: number;" line207="        constructor(parent: SpriteBehavior, leftFrames: Image[], rightFrames: Image[], interval: number) {" line208="            this._parent = parent;" line209="            this._leftFrames = leftFrames;" line210="            this._rightFrames = rightFrames;" line211="            this._interval = interval;" line212="            this._direction = 2;" line213="            this._x = -1;" line214="            this._y = -1;" line215="        }" line216="" line217="        _isDirectionChnaged() : boolean {" line218="            let direction = Math.sign(this._parent.vx);" line219="            let changed = this._direction != direction;" line220="            this._direction = direction;" line221="            return changed;" line222="        }" line223="" line224="        update() : boolean {" line225="            let isPositionChanged = Math.abs(this._x - this._parent.x) &gt; 2 || Math.abs(this._y - this._parent.y) &gt; 2;" line226="            if( !isPositionChanged )" line227="                return false;" line228="            this._x = this._parent.x;" line229="            this._y = this._parent.y;" line230="" line231="            if( !this._isDirectionChnaged() )" line232="                return false;" line233="" line234="            switch(this._direction) {" line235="            case -1:" line236="                animation.runImageAnimation(this._parent._sprite, this._leftFrames, this._interval, true);" line237="                break;" line238="            case 0:" line239="            case 1:" line240="                animation.runImageAnimation(this._parent._sprite, this._rightFrames, this._interval, true);" line241="                break;" line242="            }" line243="" line244="            return true;" line245="        }" line246="    }" line247="" line248="    class AttackerBehavior implements Behavior {" line249="        _attacker: SpriteBehavior" line250="        _attackTarget: Sprite;" line251="        _bullet: Sprite" line252="        _time: number;" line253="        constructor(attacker: SpriteBehavior, attackTarget: Sprite, bullet: Sprite) {" line254="            this._attacker = attacker;" line255="            this._attackTarget = attackTarget;" line256="            this._bullet = bullet;" line257="            this._bullet.setFlag(SpriteFlag.Invisible, true);" line258="            this._time = game.runtime();" line259="        }" line260="        update() : boolean {" line261="            let time = game.runtime();" line262="" line263="            let diff = time - this._time;" line264="            if( diff &gt; 1000) {" line265="                this._onFire();" line266="                this._time += diff;" line267="            }" line268="" line269="            return true;" line270="        }" line271="" line272="        protected _onFire() {" line273="" line274="            let x = this._attackTarget.x - this._attacker.x;" line275="            let y = this._attackTarget.y - this._attacker.y;" line276="" line277="            if( Math.abs(x) &lt; 5 &amp;&amp; Math.abs(y) &lt; 5)" line278="                return;" line279="" line280="            let n = Math.abs(x) + Math.abs(y);" line281="            let vx = x / n * 150;" line282="            let vy2 = y / n * 150;" line283="" line284="" line285="            // console.log(&quot;_onFire() x:&quot; + x + &quot; y:&quot; + y);" line286="" line287="            let bullet = sprites.create(this._bullet.image, this._bullet.kind());" line288="            bullet.setFlag(SpriteFlag.DestroyOnWall, true);" line289="            bullet.vx = vx;" line290="            bullet.vy = vy2;" line291="            bullet.x = this._attacker.x;" line292="            bullet.y = this._attacker.y;" line293="        }" line294="    }" line295="" line296="    class Item {" line297="        sprite:Sprite;" line298="        behavior:SpriteBehavior;" line299="    }" line300="" line301="    let _items: Item[] = [];" line302="    game.onUpdate(() =&gt; {" line303="        for(let item of _items) {" line304="            item.behavior.update();" line305="        }" line306="    })" line307="" line308="    //% block=&quot;set|$pattern pattern of|$sprite=variables_get(aEnemy)|vx|$vx|vy|$vy&quot;" line309="    //% vx.shadow=spriteSpeedPicker" line310="    //% vy.shadow=spriteSpeedPicker" line311="    //% inlineInputMode=inline" line312="    export function setPattern(sprite: Sprite, pattern: MovePattern, vx: number, vy: number) {" line313="        let _item = _createOrGetItemBySprite(sprite);" line314="        _item.behavior._move = _createMoverBehavior(_item.behavior, pattern, vx, vy);" line315="    }" line316="" line317="    //% block=&quot;set $sprite=variables_get(aEnemy) to follow $target=variables_get(mySprite)&quot;" line318="    export function setFollower(sprite: Sprite, target: Sprite) {" line319="        let _item2 = _createOrGetItemBySprite(sprite);" line320="        _item2.behavior._follow = new FollowerBehavior(_item2.behavior, target);" line321="    }" line322="" line323="    //% block=&quot;set $sprite=variables_get(aEnemy)|to animate left|$leftFrames=animation_editor|right|$rightFrames=animation_editor|interval|$interval (ms)&quot;" line324="    //% interval.shadow=&quot;timePicker&quot;" line325="    //% inlineInputMode=inline" line326="    export function setAnimation(sprite: Sprite, leftFrames: Image[], rightFrames: Image[], interval: number) {" line327="        let _item3 = _createOrGetItemBySprite(sprite);" line328="        _item3.behavior._animation = new AnimationBehavior(_item3.behavior, leftFrames, rightFrames, interval);" line329="    }" line330="" line331="    //% block=&quot;set $sprite=variables_get(aEnemy) to attack $target=variables_get(mySprite) by $bullet=variables_get(aBullet)&quot;" line332="    export function setAttacker(sprite: Sprite, target: Sprite, bullet: Sprite) {" line333="        let _item4 = _createOrGetItemBySprite(sprite);" line334="        _item4.behavior._attack = new AttackerBehavior(_item4.behavior, target, bullet);" line335="    }" line336="" line337="    function _createOrGetItemBySprite(sprite: Sprite) {" line338="        let _item5 = _findItemBySprite(sprite);" line339="        if( _item5 )" line340="            return _item5;" line341="" line342="        _item5 = new Item();" line343="        _item5.sprite = sprite;" line344="        _item5.behavior = new SpriteBehavior(sprite);" line345="        _addItem(_item5);" line346="        return _item5;" line347="    }" line348="" line349="    function _addItem(item: Item) {" line350="        item.sprite.onDestroyed(() =&gt; {" line351="            let _item22 = _findItemBySprite(item.sprite);" line352="            _items.removeElement(_item22);" line353="        });" line354="        _items.push(item);" line355="        // console.log(&quot;_items.length:&quot; + _items.length);" line356="    }" line357="" line358="    function _findItemBySprite(sprite:Sprite) {" line359="        let found = _items.find((_item: Item, index: number) =&gt; {" line360="            return _item.sprite == sprite;" line361="        });" line362="        if( found == undefined || found == null)" line363="            return null" line364="        return found;" line365="    }" line366="" line367="    function _createMoverBehavior(spriteBehavior: SpriteBehavior, pattern: MovePattern, vx: number, vy: number) : Behavior {" line368="        switch(pattern) {" line369="        case MovePattern.Bounce:" line370="            return new BounceBehavior(spriteBehavior, vx, vy);" line371="        case MovePattern.TurnIfOnWall:" line372="            return new TurnIfOnWallBehavior(spriteBehavior, vx, vy);" line373="        case MovePattern.BounceAndTurnOnSideWall:" line374="            return new BounceAndTurnOnSideWallBehavior(spriteBehavior, vx, vy);" line375="        case MovePattern.FlyAndTurnOnSideWall:" line376="            return new FlyAndTurnOnSideWallBehavior(spriteBehavior, vx, vy);" line377="        case MovePattern.WalkOnFloor:" line378="            return new WalkOnFloorBehavior(spriteBehavior, vx, vy);" line379="        default:" line380="            return null;" line381="        }" line382="    }" line383="" line384="}" numlines="385"></mutation></block></statement></block></xml>